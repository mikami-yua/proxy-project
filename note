动态代理（理解即可）
掌握程度：什么是动态代理，能做什么

动态代理能做什么L：
    在不改变原来目标方法功能的前提下，增加自己的功能
    开发中的意义：
        项目中的功能是别人写好的，可以使用。后来发现功能不全，不能完全满足项目的需要，需要在自己增加代码
        使用代理实现， 不用改原来的文件

jdk的动态代理必须有接口

什么是代理：
    中介，代购，换ip 等

    留学中介替学校招生
        特点：代理它们做的事是一致的：招生
            中介是学校的代理，学校是目标
            家长----中介-----美国学校
            中介会收取一些费用
            代理不让访问目标
        为什么需要中介：
            中介是专业的
            家长现在没有能力访问学校（学校不接收个人来访）

开发中的代理
    有一个A类，需要调用C类的方法实现某个功能，但是c不让a调用。在a和c之间创建一个b代理。c允许b访问。a访问b，b访问c

    实际例子：
        登录注册的验证码：手机短信。三大电信的子公司，面向社会提供发送短信的功能
作用：
    1.功能增强：在原有的功能上增加了额外的功能
    2.访问控制：字面的意思

实现方式：
    静态代理：
        代理类是自己手动实现的，自己创建一个java类，来表示代理类。
        需要代理的目标类是确定的

        特点：实现简单，理解容易
        模拟用户购买U盘的行为
        实现步骤：
            1.创建一个接口定义卖U盘的方法，表示厂家和商家要做的事
            2.创建厂家类，实现1的接口
            3.创建商家代理类，实现1的接口
            4.创建客户端类，调用商家的方法买U盘

        缺点：
            目标类增加时，代理类需要成倍增加。
            接口中增加方法，所有实现这个接口的类都需要修改
    动态代理：
        当静态代理目标类多时，可以使用动态代理，避免静态代理的缺点

        动态代理即使目标类很多，代理类的数量可以很少。
        修改接口中的方法时，对目标类没有影响

        动态代理：在程序执行的过程中，使用jdk反射机制，创建代理类对象，并动态的指定要代理的目标类
            动态代理是一种创建java对象的能力，不需要创建类就能创建对象。
        实现方式：
            jdk动态代理
                使用java反射包中的类和接口实现动态代理的功能
                反射包：java.lang.reflect  里面有三个类：InvocationHandler Method Proxy
                要求目标类必须有接口
            cglib动态代理
                cglib是一个第三方工具库，创建代理对象
                cglib的原理是继承。cglib通过继承目标类，创建子类，在子类中重写父类中同名的方法，实现修改的功能
                cglib是继承和重写：要求目标类不能是final的方法也不能是final的
                cglib要求目标类比较宽松，能继承就行
                mybatis和spring中都有使用
                可以对无接口的类使用

JDK动态代理：
    反射：
        Method类。类中的方法，通过Method类可以执行某个方法
    jdk动态代理的实现：
        反射包：java.lang.reflect
            InvocationHandler（调用处理器）------接口
                接口中只有一个方法invoke():表示代理对象要执行的功能代码
                    代理类要完成的功能写在invoke（）中
                    代理类完成的功能
                        1.调用目标方法，执行目标方法的功能
                        2.功能增强，在目标方法调用时，增强功能
                方法原型：
                    public Object invoke(Object proxy, Method method, Object[] args);//不需要人参与
                    Object proxy：jdk创建的代理对象，无需赋值
                    Method method：目标类中的方法，无需赋值jdk提供
                    Object[] args：目标类中方法的参数，无需赋值jdk提供
                使用：
                    创建类实现接口
                    重写invoke方法，把原来静态代理中代理类要完成的功能写在这里
                InvocationHandler接口：表示这个代理要干什么
            Method（表示方法的，确切的说就是目标类中的方法）-------类
                作用：通过Method可以执行某个目标类的方法。Method.invoke()//只是于上面的invoke碰巧同名
                    Method.invoke使用方法：
                        Method.invoke（目标对象，方法参数）
                        可以执行任意对象的方法，不需要知道方法的名称
                Method.invoke（）就是用来执行目标方法的，等同于静态代理中的float price=factory.sell(amount);//厂家的价格
            Proxy（核心对象，创建对象）--------类
                以前new对象，现在使用Proxy类的方法代替new对象
                    方法：静态方法newProxyInstance()
                    作用：创建代理对象等同于静态代理中 new TaoBao（）

                    方法原型：
                    public static Object newProxyInstance(ClassLoader loader,
                                                              Class<?>[] interfaces,
                                                              InvocationHandler h)
                    ClassLoader loader 类加载器，负责向内存中加载对象的。使用反射获取对象的ClassLoader
                        类a   a.getClass().getClassLoader()
                        使用目标对象的类加载器
                    Class<?>[] interfaces 接口 目标对象实现的接口，反射获取的
                    InvocationHandler 自己写的，代理类要完成的功能
    实现动态代理的步骤：
        1.创建接口，定义目标类要完成的功能
        2.创建目标类实现接口
        3.创建InvocationHandler接口实现类，在invoke方法中完成代理类的功能（不需要写接口的实现类了）
            1.调用目标方法
            2.增强功能
        4.使用Proxy类的静态方法，创建代理对象，并把返回值转为接口类型

    好处：不需要写代理类了，对接口的功能扩展只需要修改目标类即可，代理类没有影响